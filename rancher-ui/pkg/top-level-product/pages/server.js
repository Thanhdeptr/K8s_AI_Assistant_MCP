// server.jsnconst express = require('express');nconst cors = require('cors');nn// --- Polyfill fetch cho Node cũ (ưu tiên undici) ---ntry {n    const { fetch, Headers, Request, Response } = require('undici');n    Object.assign(globalThis, { fetch, Headers, Request, Response });n} catch {n    const fetch = require('node-fetch');n    Object.assign(globalThis, {n        fetch,n        Headers: fetch.Headers,n        Request: fetch.Request,n        Response: fetch.Response,n    });n}nn// --- OpenAI SDK (trỏ Ollama) ---nconst OpenAI = require('openai');nn// ====== CẤU HÌNH ======nconst OLLAMA_BASE = process.env.OLLAMA_BASE || 'http://192.168.10.32:11434/v1';nconst MODEL_NAME = process.env.MODEL_NAME || 'gpt-oss:20b'; // model trong Ollamanconst MCP_BASE = process.env.MCP_BASE || 'http://192.168.10.18:3000'; // http://host:portnn// Nếu MCP cần header như Authorization thì thêm ở đâynconst MCP_HEADERS = {n    'content-type': 'application/json',n    // 'authorization': `Bearer ${process.env.MCP_TOKEN}`,n};nn// ====== OPENAI CLIENT (Ollama-compatible) ======nconst openai = new OpenAI({n    baseURL: OLLAMA_BASE,n    apiKey: 'ollama', // placeholdern});nn// ====== MCP HTTP + SSE CLIENT ======nclass MCPHttpClient {n    constructor(base, headers = {}) {n        this.base = base.replace(//+$/, '');n        this.headers = headers;nn        this.sessionPath = null;        // "/messages?sessionId=UUID" (hoặc full URL)n        this.sessionId = null;          // Session ID để recoveryn        this.controller = null;         // AbortController cho SSEn        this.cookie = null;             // giữ Set-Cookie (nếu có)n        this.lastActivity = Date.now(); // Thêm timestamp cho activity trackingn        this.connectionState = 'disconnected'; // disconnected, connecting, connected, reconnectingnn        this._endpointReady = null;     // Promise resolve khi có sessionPathn        this._sseReader = null;         // reader của SSEn        this._buf = '';                 // buffer text SSEn        this._pending = new Map();      // id -> {resolve, reject, timer}n        this._defaultTimeoutMs = 30000; // timeout cho 1 RPC (30s)n        this._reconnectAttempts = 0;    // Số lần thử reconnectn        this._maxReconnectAttempts = 3; // Tối đa 3 lần reconnectn        this._reconnectDelay = 1000;    // Delay giữa các lần reconnect (ms)n    }nn    async connect() {n        console.log(`🔍 connect() called - sessionPath: ${this.sessionPath}, connectionState: ${this.connectionState}, sessionId: ${this.sessionId}`);n        n        if (this.sessionPath && this.connectionState === 'connected') {n            console.log('🔗 Reusing existing MCP session:', this.sessionPath);n            return this.sessionPath;n        }nn        // Thử session recovery nếu có sessionIdn        if (this.sessionId && (this.connectionState === 'disconnected' || this.connectionState === 'reconnecting')) {n            console.log('🔄 Attempting session recovery with ID:', this.sessionId);n            try {n                return await this._attemptSessionRecovery();n            } catch (error) {n                console.log('❌ Session recovery failed:', error.message);n                // Fallback to new connectionn            }n        }nn        console.log('🔄 Creating new MCP SSE connection to:', this.base);n        this.connectionState = 'connecting';n        this.controller = new AbortController();n        const r = await fetch(`${this.base}/sse`, {n            method: 'GET',n            headers: { Accept: 'text/event-stream' },n            signal: this.controller.signal,n        });n        if (!r.ok || !r.body) throw new Error(`SSE HTTP ${r.status}`);nn        // Ghi nhận Set-Cookie nếu có (một số server yêu cầu gửi lại cookie)n        const setCookie = r.headers.get('set-cookie');n        if (setCookie) this.cookie = setCookie;nn        // Promise chờ endpointn        let resolveEndpoint, rejectEndpoint;n        this._endpointReady = new Promise((res, rej) => { resolveEndpoint = res; rejectEndpoint = rej; });nn        // Bắt đầu đọc SSE và xử lý eventn        this._sseReader = r.body.getReader();n        (async () => {n            try {n                while (true) {n                    const { value, done } = await this._sseReader.read();n                    if (done) break;n                    this._buf += Buffer.from(value).toString('utf8');nn                    // Tách event theo \n\nn                    let idx;n                    while ((idx = this._buf.indexOf('\n\n')) >= 0) {n                        const raw = this._buf.slice(0, idx);n                        this._buf = this._buf.slice(idx + 2);nn                        // Parse kiểu:n                        // event: <type>n                        // data: <payload>n                        let ev = '', data = '';n                        for (const line of raw.split('\n')) {n                            const s = line.trim();n                            if (s.startsWith('event:')) ev = s.slice(6).trim();n                            else if (s.startsWith('data:')) data += (data ? '\n' : '') + s.slice(5).trim();n                        }nn                        // 1) Sự kiện cung cấp endpoint sessionn                        if (ev === 'endpoint' && data) {n                            this.sessionPath = data.startsWith('http')n                                ? data.replace(this.base, '')n                                : (data.startsWith('/') ? data : `/${data}`);n                            n                            // Extract session ID từ session pathn                            const sessionMatch = this.sessionPath.match(/sessionId=([^&]+)/);n                            if (sessionMatch) {n                                this.sessionId = sessionMatch[1];n                                console.log('📝 Extracted session ID:', this.sessionId);n                            }n                            n                            this.connectionState = 'connected';n                            if (resolveEndpoint) { resolveEndpoint(this.sessionPath); resolveEndpoint = null; }n                            continue;n                        }nn                        // 2) Sự kiện chứa JSON-RPC responsen                        if (data) {n                            // Có thể là JSON thuần hoặc NDJSON / nhiều object; ta cố parse linh hoạtn                            const candidates = data.split('\n').map(s => s.trim()).filter(Boolean);n                            for (const cand of candidates) {n                                const obj = this._tryJSON(cand) || this._tryExtractJSON(cand);n                                if (!obj || obj.jsonrpc !== '2.0' || (obj.id === undefined && obj.result === undefined && obj.error === undefined)) {n                                    continue;n                                }n                                // Nếu có id khớp pending → resolve/reject tương ứngn                                const pending = this._pending.get(obj.id);n                                if (pending) {n                                    this._pending.delete(obj.id);n                                    clearTimeout(pending.timer);n                                    if (obj.error) {n                                        pending.reject(new Error(obj.error.message || 'MCP error'));n                                    } else {n                                        pending.resolve(obj.result);n                                    }n                                }n                            }n                        }n                    }n                }nn                // SSE đóng: fail mọi pendingn                for (const [id, p] of this._pending) {n                    clearTimeout(p.timer);n                    p.reject(new Error('SSE closed'));n                }n                this._pending.clear();n                if (!this.sessionPath && rejectEndpoint) rejectEndpoint(new Error('SSE closed before endpoint'));n            } catch (e) {n                // Lỗi đọc: fail mọi pendingn                for (const [id, p] of this._pending) {n                    clearTimeout(p.timer);n                    p.reject(e);n                }n                this._pending.clear();n                if (rejectEndpoint) rejectEndpoint(e);n            }n        })();nn        // Trả về sau khi có endpoint (vẫn giữ SSE mở để nhận phản hồi RPC)n        return this._endpointReady;n    }nn    // Session recovery method - keep SSE stream open and process eventsn    async _attemptSessionRecovery() {n        if (!this.sessionId) {n            throw new Error('No session ID available for recovery');n        }nn        console.log('🔄 Attempting to recover session:', this.sessionId);nn        const recoveryUrl = `${this.base}/sse?sessionId=${this.sessionId}`;n        console.log('🔄 Making GET request to:', recoveryUrl);n        this.controller = new AbortController();nn        const r = await fetch(recoveryUrl, {n            method: 'GET',n            headers: { Accept: 'text/event-stream' },n            signal: this.controller.signal,n        });nn        console.log('🔄 Recovery response status:', r.status);n        if (!r.ok || !r.body) {n            throw new Error(`Session recovery failed: HTTP ${r.status}`);n        }nn        // Set sessionPath immediately for RPCs, expect same sessionIdn        this.sessionPath = `/messages?sessionId=${this.sessionId}`;nn        // Start reading SSE stream to receive JSON-RPC responsesn        this._sseReader = r.body.getReader();n        (async () => {n            try {n                while (true) {n                    const { value, done } = await this._sseReader.read();n                    if (done) break;n                    this._buf += Buffer.from(value).toString('utf8');nn                    let idx;n                    while ((idx = this._buf.indexOf('\n\n')) >= 0) {n                        const raw = this._buf.slice(0, idx);n                        this._buf = this._buf.slice(idx + 2);nn                        let ev = '', data = '';n                        for (const line of raw.split('\n')) {n                            const s = line.trim();n                            if (s.startsWith('event:')) ev = s.slice(6).trim();n                            else if (s.startsWith('data:')) data += (data ? '\n' : '') + s.slice(5).trim();n                        }nn                        // Optional endpoint eventn                        if (ev === 'endpoint' && data) {n                            const sessionMatch = data.match(/sessionId=([^&]+)/);n                            if (sessionMatch) {n                                this.sessionId = sessionMatch[1];n                                this.sessionPath = `/messages?sessionId=${this.sessionId}`;n                                console.log('📝 (recovered) session ID:', this.sessionId);n                            }n                            this.connectionState = 'connected';n                            continue;n                        }nn                        if (data) {n                            const candidates = data.split('\n').map(s => s.trim()).filter(Boolean);n                            for (const cand of candidates) {n                                const obj = this._tryJSON(cand) || this._tryExtractJSON(cand);n                                if (!obj || obj.jsonrpc !== '2.0' || (obj.id === undefined && obj.result === undefined && obj.error === undefined)) {n                                    continue;n                                }n                                const pending = this._pending.get(obj.id);n                                if (pending) {n                                    this._pending.delete(obj.id);n                                    clearTimeout(pending.timer);n                                    if (obj.error) {n                                        pending.reject(new Error(obj.error.message || 'MCP error'));n                                    } else {n                                        pending.resolve(obj.result);n                                    }n                                }n                            }n                        }n                    }n                }nn                // On stream close, fail pendingn                for (const [id, p] of this._pending) {n                    clearTimeout(p.timer);n                    p.reject(new Error('SSE closed'));n                }n                this._pending.clear();n            } catch (e) {n                for (const [id, p] of this._pending) {n                    clearTimeout(p.timer);n                    p.reject(e);n                }n                this._pending.clear();n            }n        })();nn        this.connectionState = 'connected';n        console.log('✅ Session recovery successful');n        return this.sessionPath;n    }nn    _tryJSON(text) {n        try { return JSON.parse(text); } catch { return null; }n    }nn    _tryExtractJSON(text) {n        const first = text.indexOf('{');n        const last = text.lastIndexOf('}');n        if (first >= 0 && last > first) {n            try { return JSON.parse(text.slice(first, last + 1)); } catch { /* ignore */ }n        }n        return null;n    }nn    // Gửi POST và chờ phản hồi qua SSE (khớp id) với retry logicn    async rpc(method, params = {}, id = Date.now()) {n        let lastError = null;n        n        for (let attempt = 0; attempt <= this._maxReconnectAttempts; attempt++) {n            try {n                if (!this.sessionPath || this.connectionState !== 'connected') {n                    console.log(`🔄 Attempt ${attempt + 1}: Connecting to MCP...`);n                    await this.connect();n                }n                n                const url = this.sessionPath.startsWith('http') ? this.sessionPath : `${this.base}${this.sessionPath}`;n                console.log(`📤 MCP RPC (attempt ${attempt + 1}):`, method, 'to', url);nn                // Tạo promise chờ SSE trả về id nàyn                const waitPromise = new Promise((resolve, reject) => {n                    const timer = setTimeout(() => {n                        this._pending.delete(id);n                        console.log('⏰ MCP RPC timeout for id', id, 'method:', method);n                        reject(new Error(`MCP RPC timeout for id ${id}`));n                    }, this._defaultTimeoutMs);n                    this._pending.set(id, { resolve, reject, timer });n                });nn                // Gửi POST (không kỳ vọng JSON trả về ở HTTP body)n                const headers = { ...this.headers, 'content-type': 'application/json' };n                if (this.cookie) headers['cookie'] = this.cookie;nn                console.log(`🔍 About to send POST to: ${url}`);n                const r = await fetch(url, {n                    method: 'POST',n                    headers,n                    body: JSON.stringify({ jsonrpc: '2.0', id, method, params }),n                });n                console.log(`🔍 POST response status: ${r.status}`);nn                // Một số server trả 200/202 kèm text "ACK..." → ta không parse JSON ở đây.n                if (!r.ok) {n                    console.log(`🔍 HTTP error detected: ${r.status}`);n                    // cố đọc body để gợi ý lỗin                    const t = await r.text().catch(() => '');n                    console.log('❌ MCP HTTP error:', r.status, t.slice(0, 200));n                    // dọn pending id vì không có phản hồi SSE hợp lện                    const p = this._pending.get(id);n                    if (p) { clearTimeout(p.timer); this._pending.delete(id); }n                    n                    // Handle 410 Gone - Session inactiven                    if (r.status === 410) {n                        console.log('🔍 Received 410 error, parsing response...');n                        try {n                            const errorData = JSON.parse(t);n                            console.log('🔍 Parsed 410 error data:', errorData);n                            if (errorData.error?.data?.action === 'reconnect_sse') {n                                console.log('🔄 Detected reconnect_sse action, throwing reconnect error');n                                console.log('🔄 About to throw error...');n                                throw new Error('Session inactive - need SSE reconnect');n                            } else {n                                console.log('❌ No reconnect_sse action found in 410 response');n                                // Vẫn throw error để trigger reconnectn                                throw new Error('Session inactive - need SSE reconnect');n                            }n                        } catch (parseError) {n                            console.log('❌ Failed to parse 410 JSON:', parseError.message);n                            // Fallback: vẫn throw error để trigger reconnectn                            throw new Error('Session inactive - need SSE reconnect');n                        }n                    }n                    n                    // Check if it's a session not found errorn                    if (t.includes('Session not found') || t.includes('session not found')) {n                        throw new Error('Session not found');n                    }n                    n                    // Throw error cho tất cả HTTP errors khácn                    throw new Error(`MCP HTTP ${r.status}: ${t.slice(0, 200)}...`);n                }nn                console.log('📥 MCP RPC sent successfully, waiting for SSE response...');n                // Chờ SSE resolve idn                return await waitPromise;n                n            } catch (error) {n                lastError = error;n                console.log(`❌ MCP RPC attempt ${attempt + 1} failed:`, error.message);n                console.log(`🔍 Full error object:`, error);n                console.log(`🔍 Error stack:`, error.stack);n                n                // Nếu là lỗi session, thử reconnectn                console.log(`🔍 Checking if error is session-related: "${error.message}"`);n                const isSessionError = error.message.includes('SSE connection not established') || n                    error.message.includes('SSE closed') ||n                    error.message.includes('timeout') ||n                    error.message.includes('Session not found') ||n                    error.message.includes('Session inactive - need SSE reconnect') ||n                    error.message.includes('MCP RPC timeout');n                n                console.log(`🔍 Is session error? ${isSessionError}`);n                n                if (isSessionError) {n                    n                    console.log(`✅ Error is session-related, checking retry attempts...`);n                    if (attempt < this._maxReconnectAttempts) {n                        console.log(`🔄 Session error detected, attempting reconnect (${attempt + 1}/${this._maxReconnectAttempts})...`);n                        this.connectionState = 'reconnecting';n                        this.sessionPath = null; // Reset để force reconnectn                        // Giữ sessionId để thử recovery trước khi tạo mớin                        n                        console.log(`🔄 Will call connect() to resume session: ${this.sessionId}`);n                        n                        // Delay trước khi thử lạin                        await new Promise(resolve => setTimeout(resolve, this._reconnectDelay * (attempt + 1)));n                        continue;n                    } else {n                        console.log(`❌ Max retry attempts reached (${this._maxReconnectAttempts})`);n                    }n                } else {n                    console.log(`❌ Error is not session-related, not retrying`);n                }n                n                // Nếu không phải lỗi session hoặc đã hết attempts, throw errorn                break;n            }n        }n        n        throw lastError || new Error('MCP RPC failed after all retry attempts');n    }nn    initialize() {n        return this.rpc('initialize', {n            protocolVersion: '2025-06-18',n            capabilities: { tools: {}, resources: {}, prompts: {} },n            clientInfo: { name: 'ollama-mcp-http', version: '0.1.0' },n        });n    }nn    async listTools() {n        const res = await this.rpc('tools/list', {}, /*id*/ Date.now() + 1);n        return res.tools || [];n    }nn    toolsCall(name, args) {n        return this.rpc('tools/call', { name, arguments: args }, /*id*/ Date.now() + 2);n    }nn    async checkHealth() {n        try {n            if (!this.sessionPath || this.connectionState !== 'connected') {n                return false;n            }n            n            // Thử gọi một RPC đơn giản để test connectionn            await this.rpc('tools/list', {}, Date.now() + 999);n            return true;n        } catch (error) {n            return false;n        }n    }nn    close() {n        try { this.controller?.abort(); } catch { }n        this.controller = null;n        this.sessionPath = null;n        this.cookie = null;n        this._endpointReady = null;n        this.connectionState = 'disconnected';n        // Không xóa sessionId để có thể recovery sau nàyn        for (const [, p] of this._pending) {n            clearTimeout(p.timer);n            p.reject(new Error('Client closed'));n        }n        this._pending.clear();n    }n}nn// ====== CHUYỂN schema MCP -> tools OpenAI-compatible (Ollama) ======nfunction mapMcpToolsToOpenAITools(mcpTools) {n    return mcpTools.map((t) => ({n        type: 'function',n        function: {n            name: t.name,n            description: t.description || `MCP tool: ${t.name}`,n            parameters: t.inputSchema || { type: 'object', properties: {} }, // JSON Scheman        },n    }));n}nnconst truncate = (s, n) =>n    (s && s.length > n ? s.slice(0, n) + '\n...[truncated]...' : s || '');nn// ====== VÒNG LẶP TOOL-CALLING (thuần Ollama) ======nasync function runToolCallingWithOllama({ userMessages, tools, mcp }) {n        const messages = userMessages.slice();n    messages.push({n      role: 'system',n      content:n        'Khi thao tác Kubernetes, hãy gọi function thích hợp (đừng đoán). ' +n        'Nếu gọi tool thì chờ kết quả tool trước khi trả lời. ' +n        'QUAN TRỌNG: Khi nhận được kết quả từ kubectl get (pods, services, deployments, etc.), ' +n        'hãy giữ nguyên format table và thêm "isMarkTable:true" ở đầu dòng đầu tiên. ' +n        'KHÔNG thay đổi format của table, chỉ thêm marker này. ' +n        'Ví dụ:\n' +n        'isMarkTable:true\n' +n        'NAME                                       READY   STATUS    RESTARTS   AGE   IP             NODE      \n' +n        'mongodb-0                                  1/1     Running   0          12d   10.244.0.117   testmcp   \n' +n        'todo-backend-app-deploy-7889844d96-b85th   1/1     Running   0          11d   10.244.0.127   testmcp     ',n    });nn    let guard = 0;n    while (guard++ < 6) {n        const completion = await openai.chat.completions.create({n            model: MODEL_NAME,n            messages,n            tools,n            tool_choice: 'auto',n        });nn        const choice = completion.choices?.[0];n        const msg = choice?.message || {};n        const toolCalls = msg.tool_calls || msg.toolCalls || [];nn        if (Array.isArray(toolCalls) && toolCalls.length > 0) {n            messages.push({ role: 'assistant', tool_calls: toolCalls });nn            for (const tc of toolCalls) {n                const { id, function: fn } = tc;n                const name = fn?.name;n                let args = {};n                try {n                    if (typeof fn?.arguments === 'string') {n                        args = JSON.parse(fn.arguments);n                    } else if (fn?.arguments && typeof fn.arguments === 'object') {n                        args = fn.arguments;n                    }n                } catch { }nn                let toolOutput = '';n                try {n                    const mcpRes = await mcp.toolsCall(name, args);n                    if (mcpRes?.content !== undefined) {n                        toolOutput = typeof mcpRes.content === 'string'n                            ? mcpRes.contentn                            : JSON.stringify(mcpRes.content);n                    } else {n                        toolOutput = JSON.stringify(mcpRes);n                    }n                    n                    // Tự động thêm isMarkTable:true cho các lệnh kubectl getn                    if (name.includes('kubectl_get') && toolOutput && !toolOutput.includes('isMarkTable:true')) {n                        // Kiểm tra nếu output có dạng table (có header và data)n                        const lines = toolOutput.split('\n').filter(line => line.trim());n                        if (lines.length >= 2) {n                            const firstLine = lines[0];n                            const secondLine = lines[1];n                            n                            // Kiểm tra nếu có header và datan                            if (firstLine.includes('NAME') && secondLine && !secondLine.includes('NAME')) {n                                toolOutput = 'isMarkTable:true\n' + toolOutput;n                            }n                        }n                    }n                } catch (e) {n                    toolOutput = `ERROR from MCP: ${e.message}`;n                }nn                messages.push({n                    role: 'tool',n                    tool_call_id: id, // quan trọng để model "ghép" đúng kết quản                    content: truncate(toolOutput, 48 * 1024),n                });n            }n            continue; // quay lại để model tổng hợpn        }nn        // Không còn tool_calls → câu trả lời cuốin        return { text: msg.content || '(no content)', trace: messages };n    }nn    return { text: '⚠️ Dừng do quá nhiều vòng tool-calling', trace: messages };n}nn// ====== EXPRESS APP ======nconst app = express();napp.use(cors());napp.use(express.json());nn// MCP client (HTTP+SSE) — tạo 1 lần và tái sử dụngnlet mcpClient = null;nlet OPENAI_COMPAT_TOOLS = [];nnasync function ensureMcp() {n    if (mcpClient) return mcpClient;n    mcpClient = new MCPHttpClient(MCP_BASE, MCP_HEADERS);n    const endpoint = await mcpClient.connect(); // GET /sse → lấy /messages?sessionId=...n    await mcpClient.initialize();n    const mcpTools = await mcpClient.listTools();n    OPENAI_COMPAT_TOOLS = mapMcpToolsToOpenAITools(mcpTools);n    console.log('🔌 MCP session endpoint:', endpoint);n    console.log('🔧 Loaded tools from MCP:', mcpTools.map(t => t.name));n    return mcpClient;n}nnapp.post('/api/chat', async (req, res) => {n    try {n        const userMessages = (req.body.messages || []).map((m) => ({n            role: m.role,n            content: m.content,n        }));nn        // 1) Kết nối MCP + lấy tools (cache)n        const mcp = await ensureMcp();nn        // 2) Chạy vòng lặp tool-calling với Ollaman        const result = await runToolCallingWithOllama({n            userMessages,n            tools: OPENAI_COMPAT_TOOLS,n            mcp,n        });nn        return res.json({ message: { content: result.text } });n    } catch (err) {n        console.error('Chat error:', err?.message || err);n        return res.status(502).json({ message: { content: '❌ Lỗi xử lý yêu cầu' } });n    }n});nn// healthnapp.get('/health', async (_req, res) => {n    try {n        await ensureMcp();n        res.json({ ok: true, ollama: OLLAMA_BASE, model: MODEL_NAME, mcp: MCP_BASE });n    } catch (e) {n        res.status(500).json({ ok: false, error: e.message });n    }n});nn// MCP status endpointnapp.get('/api/mcp/status', async (_req, res) => {n    try {n        if (!mcpClient) {n            return res.json({ n                status: 'disconnected', n                message: 'No MCP client initialized',n                sessionPath: null,n                sessionId: null,n                lastActivity: nulln            });n        }nn        const isHealthy = await mcpClient.checkHealth();n        const timeSinceLastActivity = Date.now() - mcpClient.lastActivity;n        n        res.json({ n            status: isHealthy ? 'connected' : 'unhealthy',n            connectionState: mcpClient.connectionState,n            sessionPath: mcpClient.sessionPath,n            sessionId: mcpClient.sessionId,n            lastActivity: new Date(mcpClient.lastActivity).toISOString(),n            timeSinceLastActivity: `${Math.round(timeSinceLastActivity / 1000)}s`,n            pendingRequests: mcpClient._pending.size,n            reconnectAttempts: mcpClient._reconnectAttemptsn        });n    } catch (e) {n        res.status(500).json({ n            status: 'error', n            error: e.message,n            sessionPath: mcpClient?.sessionPath || null,n            sessionId: mcpClient?.sessionId || nulln        });n    }n});nnapp.listen(8055, '0.0.0.0', () => {n    console.log('✅ API chạy: http://0.0.0.0:8055');n    console.log('🤖 Ollama baseURL:', OLLAMA_BASE, ' | MODEL:', MODEL_NAME);n    console.log('🌐 MCP base:', MCP_BASE, ' (HTTP + SSE)');n    console.log('ℹ️ Flow: GET /sse → nhận "event:endpoint" → POST JSON-RPC vào /messages?sessionId=...');n});