#!/usr/bin/env nodenimport { Server } from "@modelcontextprotocol/sdk/server/index.js";nimport { StdioServerTransport } from "@modelcontextprotocol/sdk/server/stdio.js";nimport {n  installHelmChart,n  installHelmChartSchema,n  upgradeHelmChart,n  upgradeHelmChartSchema,n  uninstallHelmChart,n  uninstallHelmChartSchema,n} from "./tools/helm-operations.js";nimport {n  explainResource,n  explainResourceSchema,n  listApiResources,n  listApiResourcesSchema,n} from "./tools/kubectl-operations.js";nimport { execInPod, execInPodSchema } from "./tools/exec_in_pod.js";nimport { getResourceHandlers } from "./resources/handlers.js";nimport {n  ListResourcesRequestSchema,n  ReadResourceRequestSchema,n  ListToolsRequestSchema,n  CallToolRequestSchema,n  ErrorCode,n  McpError,n} from "@modelcontextprotocol/sdk/types.js";nimport { KubernetesManager } from "./types.js";nimport { serverConfig } from "./config/server-config.js";nimport { cleanupSchema } from "./config/cleanup-config.js";nimport { startSSEServer } from "./utils/sse.js";nimport {n  startPortForward,n  PortForwardSchema,n  stopPortForward,n  StopPortForwardSchema,n} from "./tools/port_forward.js";nimport { kubectlScale, kubectlScaleSchema } from "./tools/kubectl-scale.js";nimport {n  kubectlContext,n  kubectlContextSchema,n} from "./tools/kubectl-context.js";nimport { kubectlGet, kubectlGetSchema } from "./tools/kubectl-get.js";nimport {n  kubectlDescribe,n  kubectlDescribeSchema,n} from "./tools/kubectl-describe.js";nimport { kubectlApply, kubectlApplySchema } from "./tools/kubectl-apply.js";nimport { kubectlDelete, kubectlDeleteSchema } from "./tools/kubectl-delete.js";nimport { kubectlCreate, kubectlCreateSchema } from "./tools/kubectl-create.js";nimport { kubectlLogs, kubectlLogsSchema } from "./tools/kubectl-logs.js";nimport {n  kubectlGeneric,n  kubectlGenericSchema,n} from "./tools/kubectl-generic.js";nimport { kubectlPatch, kubectlPatchSchema } from "./tools/kubectl-patch.js";nimport {n  kubectlRollout,n  kubectlRolloutSchema,n} from "./tools/kubectl-rollout.js";nimport { registerPromptHandlers } from "./prompts/index.js";nimport { ping, pingSchema } from "./tools/ping.js";nn// Check environment variables for tool filteringnconst allowOnlyReadonlyTools = process.env.ALLOW_ONLY_READONLY_TOOLS === "true";nconst allowedToolsEnv = process.env.ALLOWED_TOOLS;nconst nonDestructiveTools =n  process.env.ALLOW_ONLY_NON_DESTRUCTIVE_TOOLS === "true";nn// Define readonly toolsnconst readonlyTools = [n  kubectlGetSchema,n  kubectlDescribeSchema,n  kubectlLogsSchema,n  kubectlContextSchema,n  explainResourceSchema,n  listApiResourcesSchema,n  pingSchema,n];nn// Define destructive tools (delete and uninstall operations)nconst destructiveTools = [n  kubectlDeleteSchema, // This replaces all individual delete operationsn  uninstallHelmChartSchema,n  cleanupSchema, // Cleanup is also destructive as it deletes resourcesn  kubectlGenericSchema, // Generic kubectl command can perform destructive operationsn];nn// Get all available toolsnconst allTools = [n  // Core operation toolsn  cleanupSchema,nn  // Unified kubectl-style tools - these replace many specific toolsn  kubectlGetSchema,n  kubectlDescribeSchema,n  kubectlApplySchema,n  kubectlDeleteSchema,n  kubectlCreateSchema,n  kubectlLogsSchema,n  kubectlScaleSchema,n  kubectlPatchSchema,n  kubectlRolloutSchema,nn  // Kubernetes context managementn  kubectlContextSchema,nn  // Special operations that arent covered by simple kubectl commandsn  explainResourceSchema,nn  // Helm operationsn  installHelmChartSchema,n  upgradeHelmChartSchema,n  uninstallHelmChartSchema,nn  // Port forwardingn  PortForwardSchema,n  StopPortForwardSchema,n  execInPodSchema,nn  // API resource operationsn  listApiResourcesSchema,n  // Generic kubectl commandn  kubectlGenericSchema,nn  // Ping utilityn  pingSchema,n];nnconst k8sManager = new KubernetesManager();nnconst server = new Server(n  {n    name: serverConfig.name,n    version: serverConfig.version,n  },n  {n    ...serverConfig,n    capabilities: {n      prompts: {},n      ...serverConfig.capabilities,n    },n  }n);nn// Resources handlersnconst resourceHandlers = getResourceHandlers(k8sManager);nserver.setRequestHandler(n  ListResourcesRequestSchema,n  resourceHandlers.listResourcesn);nserver.setRequestHandler(n  ReadResourceRequestSchema,n  resourceHandlers.readResourcen);nn// Register prompt handlersnregisterPromptHandlers(server, k8sManager);nn// Tools handlersnserver.setRequestHandler(ListToolsRequestSchema, async () => {n  let tools;nn  if (allowedToolsEnv) {n    const allowedToolNames = allowedToolsEnv.split(",").map((t) => t.trim());n    tools = allTools.filter((tool) => allowedToolNames.includes(tool.name));n  } else if (allowOnlyReadonlyTools) {n    tools = readonlyTools;n  } else if (nonDestructiveTools) {n    tools = allTools.filter(n      (tool) => !destructiveTools.some((dt) => dt.name === tool.name)n    );n  } else {n    tools = allTools;n  }nn  return { tools };n});nnserver.setRequestHandler(n  CallToolRequestSchema,n  async (request: {n    params: { name: string; _meta?: any; arguments?: Record<string, any> };n    method: string;n  }) => {n    try {n      const { name, arguments: input = {} } = request.params;nn      // Handle new kubectl-style commandsn      if (name === "kubectl_context") {n        return await kubectlContext(n          k8sManager,n          input as {n            operation: "list" | "get" | "set";n            name?: string;n            showCurrent?: boolean;n            detailed?: boolean;n            output?: string;n          }n        );n      }nn      if (name === "kubectl_get") {n        return await kubectlGet(n          k8sManager,n          input as {n            resourceType: string;n            name?: string;n            namespace?: string;n            output?: string;n            allNamespaces?: boolean;n            labelSelector?: string;n            fieldSelector?: string;n            sortBy?: string;n          }n        );n      }nn      if (name === "kubectl_describe") {n        return await kubectlDescribe(n          k8sManager,n          input as {n            resourceType: string;n            name: string;n            namespace?: string;n            allNamespaces?: boolean;n          }n        );n      }nn      if (name === "kubectl_apply") {n        return await kubectlApply(n          k8sManager,n          input as {n            manifest?: string;n            filename?: string;n            namespace?: string;n            dryRun?: boolean;n            force?: boolean;n          }n        );n      }nn      if (name === "kubectl_delete") {n        return await kubectlDelete(n          k8sManager,n          input as {n            resourceType?: string;n            name?: string;n            namespace?: string;n            labelSelector?: string;n            manifest?: string;n            filename?: string;n            allNamespaces?: boolean;n            force?: boolean;n            gracePeriodSeconds?: number;n          }n        );n      }nn      if (name === "kubectl_create") {n        return await kubectlCreate(n          k8sManager,n          input as {n            manifest?: string;n            filename?: string;n            namespace?: string;n            dryRun?: boolean;n            validate?: boolean;n          }n        );n      }nn      if (name === "kubectl_logs") {n        return await kubectlLogs(n          k8sManager,n          input as {n            resourceType: string;n            name: string;n            namespace: string;n            container?: string;n            tail?: number;n            since?: string;n            sinceTime?: string;n            timestamps?: boolean;n            previous?: boolean;n            follow?: boolean;n            labelSelector?: string;n          }n        );n      }nn      if (name === "kubectl_patch") {n        return await kubectlPatch(n          k8sManager,n          input as {n            resourceType: string;n            name: string;n            namespace?: string;n            patchType?: "strategic" | "merge" | "json";n            patchData?: object;n            patchFile?: string;n            dryRun?: boolean;n          }n        );n      }nn      if (name === "kubectl_rollout") {n        return await kubectlRollout(n          k8sManager,n          input as {n            subCommand:n              | "history"n              | "pause"n              | "restart"n              | "resume"n              | "status"n              | "undo";n            resourceType: "deployment" | "daemonset" | "statefulset";n            name: string;n            namespace?: string;n            revision?: number;n            toRevision?: number;n            timeout?: string;n            watch?: boolean;n          }n        );n      }nn      if (name === "kubectl_generic") {n        return await kubectlGeneric(n          k8sManager,n          input as {n            command: string;n            subCommand?: string;n            resourceType?: string;n            name?: string;n            namespace?: string;n            outputFormat?: string;n            flags?: Record<string, any>;n            args?: string[];n          }n        );n      }nn      if (name === "kubectl_events") {n        return await kubectlGet(k8sManager, {n          resourceType: "events",n          namespace: (input as { namespace?: string }).namespace,n          fieldSelector: (input as { fieldSelector?: string }).fieldSelector,n          labelSelector: (input as { labelSelector?: string }).labelSelector,n          sortBy: (input as { sortBy?: string }).sortBy,n          output: (input as { output?: string }).output,n        });n      }nn      // Handle specific non-kubectl operationsn      switch (name) {n        case "cleanup": {n          await k8sManager.cleanup();n          return {n            content: [n              {n                type: "text",n                text: JSON.stringify(n                  {n                    success: true,n                  },n                  null,n                  2n                ),n              },n            ],n          };n        }nn        case "explain_resource": {n          return await explainResource(n            input as {n              resource: string;n              apiVersion?: string;n              recursive?: boolean;n              output?: "plaintext" | "plaintext-openapiv2";n            }n          );n        }nn        case "install_helm_chart": {n          return await installHelmChart(n            input as {n              name: string;n              chart: string;n              repo: string;n              namespace: string;n              values?: Record<string, any>;n            }n          );n        }nn        case "uninstall_helm_chart": {n          return await uninstallHelmChart(n            input as {n              name: string;n              namespace: string;n            }n          );n        }nn        case "upgrade_helm_chart": {n          return await upgradeHelmChart(n            input as {n              name: string;n              chart: string;n              repo: string;n              namespace: string;n              values?: Record<string, any>;n            }n          );n        }nn        case "list_api_resources": {n          return await listApiResources(n            input as {n              apiGroup?: string;n              namespaced?: boolean;n              verbs?: string[];n              output?: "wide" | "name" | "no-headers";n            }n          );n        }nn        case "port_forward": {n          return await startPortForward(n            k8sManager,n            input as {n              resourceType: string;n              resourceName: string;n              localPort: number;n              targetPort: number;n            }n          );n        }nn        case "stop_port_forward": {n          return await stopPortForward(n            k8sManager,n            input as {n              id: string;n            }n          );n        }nn        case "kubectl_scale": {n          return await kubectlScale(n            k8sManager,n            input as {n              name: string;n              namespace?: string;n              replicas: number;n              resourceType?: string;n            }n          );n        }nn        case "ping": {n          return await ping();n        }nn        case "exec_in_pod": {n          return await execInPod(n            k8sManager,n            input as {n              name: string;n              namespace?: string;n              command: string | string[];n              container?: string;n            }n          );n        }nn        default:n          throw new McpError(ErrorCode.InvalidRequest, `Unknown tool: ${name}`);n      }n    } catch (error) {n      if (error instanceof McpError) throw error;n      throw new McpError(n        ErrorCode.InternalError,n        `Tool execution failed: ${error}`n      );n    }n  }n);nn// Start the servernif (process.env.ENABLE_UNSAFE_SSE_TRANSPORT) {n  startSSEServer(server);n  console.log(`SSE server started`);n} else {n  const transport = new StdioServerTransport();nn  console.error(n    `Starting Kubernetes MCP server v${serverConfig.version}, handling commands...`n  );nn  server.connect(transport);n}nn["SIGINT", "SIGTERM"].forEach((signal) => {n  process.on(signal, async () => {n    console.log(`Received ${signal}, shutting down...`);n    await server.close();n    process.exit(0);n  });n});nnexport { allTools, destructiveTools };