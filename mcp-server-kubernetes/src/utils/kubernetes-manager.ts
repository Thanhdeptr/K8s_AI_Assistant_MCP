import * as fs from "fs";nimport * as os from "os";nimport * as path from "path";nnimport * as k8s from "@kubernetes/client-node";nnimport { ResourceTracker, PortForwardTracker, WatchTracker } from "../types.js";nnexport class KubernetesManager {n  private resources: ResourceTracker[] = [];n  private portForwards: PortForwardTracker[] = [];n  private watches: WatchTracker[] = [];n  private kc: k8s.KubeConfig;n  private k8sApi: k8s.CoreV1Api;n  private k8sAppsApi: k8s.AppsV1Api;n  private k8sBatchApi: k8s.BatchV1Api;nn  constructor() {n    this.kc = new k8s.KubeConfig();nn    if (this.hasEnvKubeconfigYaml()) {n      // Priority 1: Full kubeconfig as YAML stringn      try {n        this.loadEnvKubeconfigYaml();n        this.createTempKubeconfigFromYaml(process.env.KUBECONFIG_YAML!);n      } catch (error) {n        throw new Error(n          `Failed to parse KUBECONFIG_YAML: ${n            error instanceof Error ? error.message : "Unknown error"n          }`n        );n      }n    } else if (this.isRunningInCluster()) {n      // Priority 2: Check if running in clustern      this.kc.loadFromCluster();n    } else if (this.hasEnvKubeconfigJson()) {n      // Priority 3: Full kubeconfig as JSON stringn      try {n        this.loadEnvKubeconfigJson();n        // Create temp kubeconfig file for kubectl commands from JSONn        const yamlConfig = this.kc.exportConfig();n        this.createTempKubeconfigFromYaml(yamlConfig);n      } catch (error) {n        throw new Error(n          `Failed to parse KUBECONFIG_JSON: ${n            error instanceof Error ? error.message : "Unknown error"n          }`n        );n      }n    } else if (this.hasEnvMinimalKubeconfig()) {n      // Priority 4: Minimal config with individual environment variablesn      try {n        this.loadEnvMinimalKubeconfig();n        // Create temp kubeconfig file for kubectl commands from minimal confign        const yamlConfig = this.kc.exportConfig();n        this.createTempKubeconfigFromYaml(yamlConfig);n      } catch (error) {n        throw new Error(n          `Failed to create kubeconfig from K8S_SERVER and K8S_TOKEN: ${n            error instanceof Error ? error.message : "Unknown error"n          }`n        );n      }n    } else if (this.hasEnvKubeconfigPath()) {n      // Priority 5: Custom kubeconfig file path using KUBECONFIG_PATHn      try {n        this.loadEnvKubeconfigPath();n        // Set KUBECONFIG environment variable to the custom path for kubectl commandsn        process.env.KUBECONFIG = process.env.KUBECONFIG_PATH;n      } catch (error) {n        throw new Error(n          `Failed to load kubeconfig from KUBECONFIG_PATH: ${n            error instanceof Error ? error.message : "Unknown error"n          }`n        );n      }n    } else if (this.hasEnvKubeconfig()) {n      // Load from KUBECONFIGn      this.kc.loadFromFile(process.env.KUBECONFIG!);n    } else {n      // Priority 7: Default file-based configuration (existing fallback)n      this.kc.loadFromDefault();n    }nn    // Apply context override if specifiedn    if (process.env.K8S_CONTEXT) {n      try {n        this.setCurrentContext(process.env.K8S_CONTEXT);n      } catch (error) {n        console.warn(n          `Warning: Could not set context to ${process.env.K8S_CONTEXT}: ${n            error instanceof Error ? error.message : "Unknown error"n          }`n        );n      }n    }nn    // Initialize API clientsn    this.k8sApi = this.kc.makeApiClient(k8s.CoreV1Api);n    this.k8sAppsApi = this.kc.makeApiClient(k8s.AppsV1Api);n    this.k8sBatchApi = this.kc.makeApiClient(k8s.BatchV1Api);n  }nn  /**n   * A very simple test to check if the application is running inside a Kubernetes clustern   */n  private isRunningInCluster(): boolean {n    const serviceAccountPath =n      "/var/run/secrets/kubernetes.io/serviceaccount/token";n    try {n      return fs.existsSync(serviceAccountPath);n    } catch {n      return false;n    }n  }nn  /**n   * Check if KUBECONFIG_YAML environment variable is availablen   */n  private hasEnvKubeconfigYaml(): boolean {n    return !!(n      process.env.KUBECONFIG_YAML && process.env.KUBECONFIG_YAML.trim()n    );n  }nn  /**n   * Check if KUBECONFIG_JSON environment variable is availablen   */n  private hasEnvKubeconfigJson(): boolean {n    return !!(n      process.env.KUBECONFIG_JSON && process.env.KUBECONFIG_JSON.trim()n    );n  }nn  /**n   * Check if minimal K8S_SERVER and K8S_TOKEN environment variables are availablen   */n  private hasEnvMinimalKubeconfig(): boolean {n    return !!(n      process.env.K8S_SERVER &&n      process.env.K8S_SERVER.trim() &&n      process.env.K8S_TOKEN &&n      process.env.K8S_TOKEN.trim()n    );n  }nn  /**n   * Load kubeconfig from KUBECONFIG_PATH environment variable (file path)n   */n  private loadEnvKubeconfigPath(): void {n    this.kc.loadFromFile(process.env.KUBECONFIG_PATH!);n  }nn  /**n   * Load kubeconfig from KUBECONFIG_YAML environment variable (YAML format)n   */n  private loadEnvKubeconfigYaml(): void {n    if (!process.env.KUBECONFIG_YAML) {n      throw new Error("KUBECONFIG_YAML environment variable is not set");n    }nn    // Load the config into the JavaScript clientn    this.kc.loadFromString(process.env.KUBECONFIG_YAML);n  }nn  /**n   * Load kubeconfig from KUBECONFIG_JSON environment variable (JSON format)n   */n  private loadEnvKubeconfigJson(): void {n    const configObj = JSON.parse(process.env.KUBECONFIG_JSON!);n    this.kc.loadFromOptions(configObj);n  }nn  /**n   * Load kubeconfig from minimal K8S_SERVER and K8S_TOKEN environment variablesn   */n  private loadEnvMinimalKubeconfig(): void {n    if (!process.env.K8S_SERVER || !process.env.K8S_TOKEN) {n      throw new Error(n        "K8S_SERVER and K8S_TOKEN environment variables are required"n      );n    }nn    const cluster = {n      name: "env-cluster",n      server: process.env.K8S_SERVER,n      skipTLSVerify: process.env.K8S_SKIP_TLS_VERIFY === "true",n    };nn    const user = {n      name: "env-user",n      token: process.env.K8S_TOKEN,n    };nn    const context = {n      name: "env-context",n      user: user.name,n      cluster: cluster.name,n    };nn    const kubeconfigContent = {n      clusters: [cluster],n      users: [user],n      contexts: [context],n      currentContext: context.name,n    };nn    this.kc.loadFromOptions(kubeconfigContent);n  }nn  /**n   * Check if KUBECONFIG_PATH environment variable is availablen   */n  private hasEnvKubeconfigPath(): boolean {n    return !!(n      process.env.KUBECONFIG_PATH && process.env.KUBECONFIG_PATH.trim()n    );n  }nn  private hasEnvKubeconfig(): boolean {n    return !!(process.env.KUBECONFIG && process.env.KUBECONFIG.trim());n  }nn  /**n   * Set the current context to the desired context name.n   *n   * @param contextNamen   */n  public setCurrentContext(contextName: string) {n    // Get all available contextsn    const contexts = this.kc.getContexts();n    const contextNames = contexts.map((context) => context.name);nn    // Check if the requested context existsn    if (!contextNames.includes(contextName)) {n      throw new Error(n        `Context ${contextName} not found. Available contexts: ${contextNames.join(n          ", "n        )}`n      );n    }n    // Set the current contextn    this.kc.setCurrentContext(contextName);n    this.k8sApi = this.kc.makeApiClient(k8s.CoreV1Api);n    this.k8sAppsApi = this.kc.makeApiClient(k8s.AppsV1Api);n    this.k8sBatchApi = this.kc.makeApiClient(k8s.BatchV1Api);n  }nn  async cleanup() {n    // Stop watchesn    for (const watch of this.watches) {n      watch.abort.abort();n    }nn    // Delete tracked resources in reverse ordern    for (const resource of [...this.resources].reverse()) {n      try {n        await this.deleteResource(n          resource.kind,n          resource.name,n          resource.namespacen        );n      } catch (error) {n        process.stderr.write(n          `Failed to delete ${resource.kind} ${resource.name}: ${error}n`n        );n      }n    }n  }nn  trackResource(kind: string, name: string, namespace: string) {n    this.resources.push({ kind, name, namespace, createdAt: new Date() });n  }nn  async deleteResource(kind: string, name: string, namespace: string) {n    switch (kind.toLowerCase()) {n      case "pod":n        await this.k8sApi.deleteNamespacedPod({ name, namespace });n        break;n      case "deployment":n        await this.k8sAppsApi.deleteNamespacedDeployment({ name, namespace });n        break;n      case "service":n        await this.k8sApi.deleteNamespacedService({ name, namespace });n        break;n      case "cronjob":n        await this.k8sBatchApi.deleteNamespacedCronJob({ name, namespace });n        break;n    }n    this.resources = this.resources.filter(n      (r) => !(r.kind === kind && r.name === name && r.namespace === namespace)n    );n  }nn  trackPortForward(pf: PortForwardTracker) {n    this.portForwards.push(pf);n  }nn  getPortForward(id: string) {n    return this.portForwards.find((p) => p.id === id);n  }nn  removePortForward(id: string) {n    return this.portForwards.filter((p) => p.id !== id);n  }nn  trackWatch(watch: WatchTracker) {n    this.watches.push(watch);n  }nn  getKubeConfig() {n    return this.kc;n  }nn  getCoreApi() {n    return this.kc.makeApiClient(k8s.CoreV1Api);n  }nn  getAppsApi() {n    return this.kc.makeApiClient(k8s.AppsV1Api);n  }nn  getBatchApi() {n    return this.kc.makeApiClient(k8s.BatchV1Api);n  }nn  /**n   * Get the default namespace for operationsn   * Uses K8S_NAMESPACE environment variable if set, otherwise defaults to "default"n   */n  getDefaultNamespace(): string {n    return process.env.K8S_NAMESPACE || "default";n  }nn  /**n   * Create temporary kubeconfig file from YAML content for kubectl commandsn   * @param kubeconfigYaml YAML content of the kubeconfign   */n  private createTempKubeconfigFromYaml(kubeconfigYaml: string): void {n    try {n      if (!kubeconfigYaml || typeof kubeconfigYaml !== "string") {n        throw new Error(`Invalid kubeconfigYaml: ${typeof kubeconfigYaml}`);n      }nn      const tempDir = os.tmpdir();n      const timestamp = new Date().toISOString().replace(/[:.]/g, "-");n      const randomString = Math.random().toString(36).substring(2);n      const tempKubeconfigPath = path.join(n        tempDir,n        `kubeconfig-${timestamp}-${randomString}`n      );nn      // Write temporary kubeconfig filen      fs.writeFileSync(tempKubeconfigPath, kubeconfigYaml, {n        mode: 0o600,n        encoding: "utf8",n      });nn      // Set KUBECONFIG environment variable for kubectl commandsn      process.env.KUBECONFIG = tempKubeconfigPath;nn      // Function to clean up the temporary filen      const cleanupTempFile = () => {n        try {n          if (fs.existsSync(tempKubeconfigPath)) {n            fs.unlinkSync(tempKubeconfigPath);n          }n        } catch (cleanupError) {n          // Ignore cleanup errorsn        }n      };nn      // Schedule cleanup of temporary file when process exitsn      process.on("exit", cleanupTempFile);nn      // Also clean up on SIGINT and SIGTERM (common in Docker containers)n      ["SIGINT", "SIGTERM"].forEach((signal) => {n        process.on(signal, () => {n          cleanupTempFile();n          process.exit(0);n        });n      });nn      // Additional cleanup for Docker container lifecyclen      ["SIGUSR1", "SIGUSR2"].forEach((signal) => {n        process.on(signal, cleanupTempFile);n      });n    } catch (error) {n      // Continue without temporary file - kubectl commands may fail but JavaScript client will workn      throw error;n    }n  }n}